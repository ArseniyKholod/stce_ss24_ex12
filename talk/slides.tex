\documentclass[ucs,10pt]{beamer}
 
\include{stce-beamer-template}  

\begin{document}
\title[{\tt info@stce.rwth-aachen.de}]{\textcolor{rwth-blue}{Software Lab Computational Engineering Science} \vspace{.2cm} \\ {\small Group 12, Exception Handling}}
\author[Group 12)]{Aaron Floerke, Arseniy Kholod, Xinyang Song and Yanliang Zhu} 
\institute[Software Lab CES]{
{Informatik 12: Software and Tools for Computational Engineering (STCE)} \\ RWTH Aachen University \vspace{.5cm}
}
\date[]{24.06.2024}

\begin{frame}[plain]
\titlepage
\end{frame}

\begin{frame}
	\frametitle{Contents}
\tableofcontents
\end{frame}

\section{Analysis}

\subsection{User Requirements}

\begin{frame}
\frametitle{Analysis \\
	\small \color{rwth-blue} User Requirements}
	\begin{itemize}
		\item Extend cppNum v2.4 and v2.5 with appropriate C++ exception handling.
		\item Desing at least three scalable sufficiently distinct case studies.
		\item Compare general behavior and run times with the exception handling-free version.
	\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Analysis \\
	\small \color{rwth-blue} Definition Exception Handling}
	\begin{itemize}
		\item Exception handling is a programming concept used to manage errors and unusual conditions that arise during program execution. It allows for controlled responses to errors, ensuring the program can handle them gracefully without crashing. Key components include try, catch (or except), and finally blocks. (ChatGPT)
	\end{itemize}
\end{frame}

\subsection{System Requirements}

\begin{frame}
\frametitle{Analysis \\
	\small \color{rwth-blue} System Requirements}
	Functional:
	\begin{itemize}
		\item \textbf{Exception Handling:}
		\begin{itemize}
			\item An exception is thrown, if unintended input is put into the system
			\item An exception is thrown when the system behaves in an unintended way. 
                \item An exception should be handled in such a way, as to prevent a potential crash of the system, if possible.
			\item The system must integrate C++ exception handling mechanisms in cppNum versions v2.4 and v2.5.
			\item The system must log all exceptions with appropriate error messages.
                \item A thrown exception should enhance the users ability to find bugs.
		\end{itemize}
		\item \textbf{Case Studies:}
		\begin{itemize}
			\item The system must implement at least three scalable and distinct case studies to test the modified cppNum library.
			\item Each case study must include a specific scenario that can trigger exceptions.
		\end{itemize}
		\item \textbf{Performance Comparison:}
		\begin{itemize}
			\item The system must compare the general behavior and run times of the modified cppNum versions with the original exception-free versions.
			\item The comparison results must be documented and include detailed performance metrics.
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Analysis \\
	\small \color{rwth-blue} System Requirements}
	Nonfunctional:
	\begin{itemize}
		\item \textbf{Exception Structure:}
		\begin{itemize}
			\item An exception is a class object.
			\item All cppNum exception classes have a single parent class to provide a clear structure.
			\item All exception classes are inherited from std::exception to catch together with other exceptions, potentially generated by third-party libraries.
		\end{itemize}
             \item \textbf{Exception Logic:}
		\item \textbf{Performance:}
		\begin{itemize}
			\item The system must ensure that the overhead introduced by exception handling is minimized.
			\item The system should not degrade the performance of cppNum versions v2.4 and v2.5.
		\end{itemize}
		\item \textbf{Reliability:}
		\begin{itemize}
			\item The system must handle exceptions gracefully to prevent crashes and ensure smooth operation.
			\item The system must be able to recover from exceptions and continue processing if possible.
		\end{itemize}
        \end{itemize}
\end{frame}

\begin{frame}
\frametitle{Analysis \\
	\small \color{rwth-blue} System Requirements}
	\begin{itemize}	
            \item \textbf{Usability:}
		\begin{itemize}
			\item The system must provide clear and informative error messages to users when exceptions occur.
			\item The system should document the scenarios under which exceptions are raised and how they are handled.
		\end{itemize}
		\item \textbf{Maintainability:}
		\begin{itemize}
			\item The code implementing exception handling must be well-documented and follow coding standards.
			\item The system must use modular and clean code to facilitate future updates and maintenance.
		\end{itemize}
		\item \textbf{Scalability:}
		\begin{itemize}
			\item The system must be able to handle large datasets and complex computations in the case studies without significant performance degradation.
			\item The system must be designed to easily incorporate additional case studies in the future.
		\end{itemize}
	\end{itemize}
\end{frame}

\begin{frame}
\frametitle{Design \\
	\small \color{rwth-blue} Principal Components and Third-Party Software}
	\begin{itemize}
		\item Third-Party libraries: Eigen and AD.
		\item Wrap with try-catch every connection point to Eigen and AD to handle possible exceptions. All exceptions that could be thrown by Eigen and AD are inherited from std::exception.
		\item Rethrow exceptions recursively to the highest level function. This provide so-called stack-trace inside cppNum.
		\item Implement exception classes inherited from std::exception to handle exceptions generated by cppNum itself.
		\item Check applicability of LU and LLT decompositions utilizing functions from Eigen. Generate custom exceptions in error cases.
	\end{itemize}
\end{frame}

\subsection{Class Model(s)}

\begin{frame}
\frametitle{Design \\
	\small \color{rwth-blue} Class Model(s)}
	\begin{figure}
                \centering
                \includegraphics[width=0.8\textwidth]{figures/class_diagramm.png}
        \end{figure}
\end{frame}



\section{Implementation}

\subsection{Development Infrastructure}

\begin{frame}
\frametitle{Implementation \\
	\small \color{rwth-blue} Development Infrastructure}
	\begin{itemize}	
		\item \textbf{1. Operating System:}
			\begin{itemize}
				\item Xubuntu
			\end{itemize}
		\item \textbf{2. Programming Language and Compiler:}
			\begin{itemize}
				\item Programming Language: C++.
				\item Compiler: GCC.
			\end{itemize}
		\item \textbf{3. Libraries:}
			\begin{itemize}
				\item Eigen: A C++ library for linear algebra, providing efficient matrix and vector operations.
				\item AD: Provide a complete C++ solution for implementing algorithmic differentiation in numerical computations.
			\end{itemize}
		\item \textbf{4. Version Control System:}
			\begin{itemize}
				\item GitHub: Remote code repositories for team collaboration, code reviews, and version control. \url{https://github.com/ArseniyKholod/stce_ss24_ex12}
			\end{itemize}
		\item \textbf{5. Frameworks:}
			\begin{itemize}
				\item Doxygen: Used for generating project documentation, helping the team understand and maintain the code better.
				\item Makefile: For build management.
			\end{itemize}
	\end{itemize}
\end{frame}



\subsection{Source Code}

\begin{frame}
\frametitle{Implementation \\
	\small \color{rwth-blue} Sutructure of source code}
	\begin{columns}
         	\begin{column}{0.5\textwidth}
			\setlength{\parindent}{2em}
			cppNum \textbf{v2.4} \newline
			  \indent exceptions \newline
		    	    \indent \indent cppNum\_exception.hpp \newline
		   	    \indent \indent math\_error.hpp \newline
		    	    \indent \indent logic\_error.hpp \newline
		  	  \indent convexObjective \newline
		    	    \indent \indent objective.hpp \newline
		    	    \indent \indent newton.hpp \newline
		    	    \indent \indent minimizer.hpp \newline
		  	  \indent algebraicSystem \newline
		    	    \indent \indent system.hpp \newline
		    	    \indent \indent solver.hpp \newline
		    	    \indent \indent newton.hpp \newline
		  	  \indent linearAlgebra.hpp \newline
		  	  \indent iteration.hpp \newline
		  	  \indent derivative.hpp \newline
		  	  \indent approximation.hpp \newline
		\end{column}
		\begin{column}{0.5\textwidth}
			\setlength{\parindent}{2em} \vspace{1mm} \newline
                	cppNum \textbf{v2.5} \newline
                  	  \indent exceptions \newline
                   	    \indent \indent cppNum\_exception.hpp \newline
               		    \indent \indent math\_error.hpp \newline
                	    \indent \indent logic\_error.hpp \newline
                	  \indent differentialSystem \newline
               		    \indent \indent system.hpp \newline
                 	    \indent \indent integrator.hpp \newline
                 	    \indent \indent implicitEuler.hpp \newline
                 	  \indent algebraicSystem \newline
                 	    \indent \indent system.hpp \newline
                 	    \indent \indent solver.hpp \newline
                  	    \indent \indent newton.hpp \newline
                 	  \indent linearAlgebra.hpp \newline
               	 	  \indent iteration.hpp \newline
                 	  \indent derivative.hpp \newline
                 	  \indent approximation.hpp \newline
		 	  \indent evolution.hpp \newline
     		\end{column}
	\end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Source Code \\
        \small \color{rwth-blue} cppNum/exceptions/cppNum\_exception.hpp v2.4 and v2.5 }
	\begin{lstlisting}
	#pragma once
	#include <exception>
	namespace ex{
  	  /// Abstract basic class for all cppNum exceptions
  	  class cppNum_exception: public std::exception{
    	    public:
    	      virtual const char* what() const noexcept =0;
  	  };
	}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Source Code \\
        \small \color{rwth-blue} cppNum/exceptions/math\_error.hpp v2.4 and v2.5 }
	\begin{lstlisting}
        #pragma once
        #include "cppNum_exception.hpp"
        #include <string>
        namespace ex{
          /// An exception class to handle mathematical errors
          class math_error: public cppNum_exception {
            protected:
              /// Error message
              const char* what_arg;
            public:
              /// Constructor to initialize error message
              math_error(const char*);
              /// Copy constructor
              math_error(const math_error&);
              /// Returns explanatory string
              virtual const char* what() const noexcept{
                return what_arg;
              }
          };

          math_error::math_error(const char* what_arg) : what_arg(what_arg){}
          math_error::math_error(const math_error& err){
            what_arg = err.what_arg;
          }
        }
        \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Source Code \\
        \small \color{rwth-blue} cppNum/exceptions/logic\_error.hpp v2.4 and v2.5 }
	\begin{lstlisting}
	#pragma once
	#include "cppNum_exception.hpp"
	#include <string>
	
	namespace ex{
	  /// An exception class to handle logical errors
	  class logic_error: public cppNum_exception {
	    protected:
	      /// Error message
	      const char* what_arg;
	    public:
	      /// Constructor to initialize error message
	      logic_error(const char*);
	      /// Copy constructor
	      logic_error(const logic_error&);
	      /// Returns explanatory string
	      virtual const char* what() const noexcept{
	        return what_arg;
	      }
	  };
		
	  logic_error::logic_error(const char* what_arg) : what_arg(what_arg){}
	  logic_error::logic_error(const logic_error& err){
	    what_arg = err.what_arg;
	  }
	}
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Source Code \\
        \small \color{rwth-blue} cppNum/linearAlgebra.hpp v2.4 and v2.5, LU }
	\begin{lstlisting}
	...
	template<typename T>
	struct lu_solver_t {
	  static la::vector_t<T> run(const la::matrix_t<T>& A, const la::vector_t<T>& b) {
	    try{
	      //matrix have to be square
	      if(A.cols() != A.rows())
	        throw(ex::math_error("Matrix is not square, LU decomposition is not applicable"));
	      //matrix and vector must have equal number of rows
	      if(A.rows() != b.rows())
	        throw(ex::math_error("Matrix and rhs-vector have diffirent number of rows, linear system is not uniquely solvable"));
	      //matrix have to be invertible
	      if(A.determinant() == 0)
	        throw(ex::math_error("Matrix is singular, applying LU algorithm for solving a linear system is not possible."));
	      return A.lu().solve(b);
	    }
	    catch(...){
	      std::cerr<<"Exception was caught in la::lu_solver_t::run, throw it further."<<std::endl;
	      throw;
	    }
	  }
  	};
	...
	\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Source Code \\
        \small \color{rwth-blue} cppNum/linearAlgebra.hpp v2.4 and v2.5, LLT }
	\begin{lstlisting}
	  ...
	  template<typename T>
	  struct llt_solver_t {
	    static la::vector_t<T> run(const la::matrix_t<T>& A, const la::vector_t<T>& b) {
	      try{
	        //matrix have to be squared
	        if(A.cols() != A.rows())
	          throw(ex::math_error("Matrix is not square, LLT decomposition is not applicable"));
	        //matrix and vector must have equak number of rows
	        if(A.rows() != b.rows())
	          throw(ex::math_error("Matrix and rhs-vector have diffirent number of rows, linear system is not uniquely solvable"));
	        //matrix have to be invertible
	        if(A.determinant() == 0)
	          throw(ex::math_error("Matrix is singular, applying LLT algorithm for solving a linear system is not possible."));
	        //matrix have to be symmetric positive definite
	        if(A.llt().info())
	          throw(ex::math_error("Matrix is not symmetric positiv definite, LLT decomposition is not applicable."));
	        return A.llt().solve(b);
	      }
	      catch(...){
	        std::cerr<<"Exception was caught in la::llt_solver_t::run, throw it further."<<std::endl;
	        throw;
	      }
	    }
  	  };
	  ...
        \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Source Code \\
        \small \color{rwth-blue} cppNum/derivative.hpp v2.4 and v2.5 }
	Content of each function in cppNum/derivative.hpp was wrapped in try and followed by catch. E.g. for dFdx,for all other functions exactly in the same way.
        \begin{lstlisting}
	...
	static la::matrix_t<T> dFdx(const la::vector_t<T>& x_v, const la::vector_t<T>& p_v) {
	  try{...
	  }
	  catch(...){
	    std::cerr<<"Exception was caught in derivative_t::dFdx, throw it further."<<std::endl;
	    throw;
	  }
	}
	...
        \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Source Code \\
        \small \color{rwth-blue} cppNum/algebraicSystem/newton.hpp v2.4 and v2.5 }
	\begin{lstlisting}
        ...
  	  template<typename T, typename SYSTEM_T, typename LINEAR_SOLVER_T>
	  la::vector_t<T> newton_solver_t<T,SYSTEM_T,LINEAR_SOLVER_T>::run(la::vector_t<T> x, const la::vector_t<T> &p) {
	    try{...
	    }
	    catch(...){
	      std::cerr<<"Exception was caught in as::newton_solver_t::run, throw it further."<<std::endl;
	      throw;
	    }
	  }
	...
        \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{Source Code \\
        \small \color{rwth-blue} cppNum/convexObjective/newton.hpp v2.4 }
	\begin{lstlisting}[basicstyle=\tiny\sffamily]
	  ...
	  la::vector_t<AS_T> newton_minimizer_t<T,LINEAR_SOLVER_T>::F(const la::vector_t<AS_T> &x, const la::vector_t<AS_T>& p) {
	    try{
	      return derivative_t::dfdx<objective_t,AS_T>(x,p);
	    }
	    catch(...){
	      std::cerr<<"Exception was caught in co::newton_minimizer_t::F, throw it further."<<std::endl;
	      throw;
	    }
  	  }
	  ...
	  la::vector_t<T> newton_minimizer_t<T,LINEAR_SOLVER_T>::run(la::vector_t<T> x, const la::vector_t<T> &p) {
	    la::vector_t<T> x_initial(x);
	    try{
	      ...	
	      return x;
	    }
	    catch(const std::exception & e){
	      std::cerr<<"std:exception was caught in co::newton_minimizer_t::run with following message:"<<std::endl<<e.what()<<std::endl;
	    }
	    catch(...){
	      std::cerr<<"Exception of unknown type was caught in co::newton_minimizer_t::run."<<std::endl;
	    }
	    std::cerr<<"co::newton_minimizer_t::run returns an initial value of x. Check the correctness of the input."<<std::endl;
	    return x_initial;

	  }
	...
        \end{lstlisting}
	The highest level function in v2.4 is co::newton\_minimizer\_t::run, it does not rethrow an error, it prints the message and returns an initial value to user.
\end{frame}

\begin{frame}[fragile]
\frametitle{Source Code \\
        \small \color{rwth-blue} cppNum/differentialSystem/implicitEuler.hpp v2.5 }
        \begin{lstlisting}
        ...
	  template<typename T>
	  la::vector_t<T> implicitEuler_integrator_t<T>::run(la::vector_t<T> x, const la::vector_t<T> &p) {
	    la::vector_t<T> x_initial(x);
	    try{...
	      return x;
	    }
	    catch(const std::exception & e){
	      std::cerr<<"std:exception was caught in ds::implicitEuler_integrator_t::run with following message:"<<std::endl<<e.what()<<std::endl;
	    }
	    catch(...){
	      std::cerr<<"Exception of unknown type was caught in ds::implicitEuler_integrator_t::run."<<std::endl;
	    }
	    std::cerr<<"ds::implicitEuler_integrator_t::run returns an initial value of x. Check the correctness of the input."<<std::endl;
	    return x_initial;
	  }
	...
        \end{lstlisting}
        The highest level function in v2.5 is ds::implicitEuler\_integrator\_t::run, it does not rethrow an error, it prints the message and returns an initial value to user.
\end{frame}

\begin{frame}[fragile]
\frametitle{Source Code \\
        \small \color{rwth-blue} Additional: plot functions v2.4 and v2.5 }
	In all plot functions was checked, whether requested state exists. These functions were wrapped in try and followed by catch. E.g. for evolution\_t::plot from v2.5, all other plots in the same way.
	\begin{lstlisting}
	template<typename T>
	void evolution_t<T>::plot(const std::string& filename, int i) const {
	  try{
	    std::ofstream ofs(filename);
	    assert(_states.size()==_times.size());
	    //check if requested state exists
	    if(i < 0 || i >= _states[0].rows())
	      throw(ex::logic_error("State outside range is requested."));
	    for (size_t k=0; k<_times.size(); ++k)
	      ofs << _times[k] << ' ' << _states[k](i) << std::endl;
	  }
	  catch(const std::exception & e){
	    std::cerr<<"std:exception was caught in evolution_t::plot with following message:"<<std::endl<<e.what()<<std::endl;
	  }
	  catch(...){
	    std::cerr<<"Exception of unknown type was caught in evolution_t::plot."<<std::endl;
	  }
	}
        \end{lstlisting}
\end{frame}

\subsection{Documentation}

\begin{frame}
\frametitle{Implementation \\
        \small \color{rwth-blue} Documentation with Doxygen}
	Example is for v2.4, analogically for v2.5.
        \begin{figure}
		\includegraphics[width=0.65\textwidth]{figures/class_hierarchy_doc.png}                
        \end{figure}
\end{frame}

\begin{frame}
\frametitle{Implementation \\
        \small \color{rwth-blue} Documentation with Doxygen}
	\begin{figure}[b]
		\includegraphics[width=0.35\textwidth]{figures/cppNum_exception_doc.png}
                \includegraphics[width=0.3\textwidth]{figures/math_error_doc.png}
                \includegraphics[width=0.28\textwidth]{figures/logic_error_doc.png}
        \end{figure}
\end{frame}

\subsection{Software Tests}

\begin{frame}[fragile]
\frametitle{Implementation: Case Study \\
	\small \color{rwth-blue} Function: 4th order convex polynomial}
	The function is:
	\[ f(x, p) = 0.5 \cdot (p(i) + x(i))^2 + 0.2 \cdot (x(i) - p(i))^4 \]
	\begin{lstlisting}
		#pragma once
		#include "cppNum/convexObjective/objective.hpp"
		#include <cassert>
		#include <cmath>
		
		template<typename T> 
		T co::objective_t::f(const la::vector_t<T> &x, const la::vector_t<T> &p) { 
		using namespace std;
		int n=x.size(); assert(n>=1); assert(p.size()==n);
		T y=0;
		for (int i=0;i<n;++i) y+=0.5*pow(p(i)+x(i),2) + 0.2*pow(x(i)-p(i),4);
		return y;
		}
	\end{lstlisting}
\end{frame}
	
\begin{frame}[fragile]
\frametitle{Implementation: Case Study \\
	\small \color{rwth-blue} Function: cosh}
	The function is:
	\[ f(x, p) = \cosh(x(i) + p(i)) \]
	\begin{lstlisting}
		#pragma once
		#include "cppNum/convexObjective/objective.hpp"
		#include <cassert>
		#include <cmath>
		
		template<typename T> 
		T co::objective_t::f(const la::vector_t<T> &x, const la::vector_t<T> &p) { 
		using namespace std;
		int n=x.size(); assert(n>=1); assert(p.size()==n);
		T y=0;
		for (int i=0;i<n;++i) y+=cosh(x(i)+p(i));
		return y;
		}
	\end{lstlisting}
\end{frame}
	
\begin{frame}[fragile]
\frametitle{Implementation: Case Study \\
	\small \color{rwth-blue} Function: fountain chain}
	\begin{figure}
		\centering
		\includegraphics[width=0.8\textwidth]{figures/fountain_chain.png}
		\caption{Fountain Chain}
	\end{figure}
\end{frame}
	
\begin{frame}[fragile]
\frametitle{Implementation: Case Study \\
	\small \color{rwth-blue} Function: fountain chain}
	The function is:
	\[
	r(0) = \frac{1}{p_2} \left( p_0 - p_3 \sqrt{2 p_1 x_0} \right)
	\]
	
	\[
	r(i) = \frac{1}{p_{2i+2}} \left( p_{2i+1} \sqrt{2 p_1 x_{i-1}} - p_{2i+3} \sqrt{2 p_1 x_i} \right), \quad i = 1, 2, \ldots, n-1
	\]
	\begin{lstlisting}
		#pragma once
		#include "cppNum/differentialSystem/system.hpp"
		#include <cassert>
		
		template<typename T>
		la::vector_t<T> ds::system_t::G(const la::vector_t<T> &x, const la::vector_t<T> &p) {
		int n = x.size();
		assert(p.size() == 2*n + 2);
		assert(n >= 2);
		la::vector_t<T> r(n);
		r(0) = (1/p(2))*(p(0) - p(3)*sqrt(2*p(1)*x(0)));
		for(int i = 1; i < n; i++) {
			r(i) = (1/p(2*i + 2))*(p(2*i + 1)*sqrt(2*p(1)*x(i - 1)) - p(2*i + 3)*sqrt(2*p(1)*x(i)));
		}
		return r;
	}
	\end{lstlisting}
\end{frame}
		
\begin{frame}[fragile]
\frametitle{Implementation: Case Study \\
	\small \color{rwth-blue} Function: linear ode}
	The function is:
	\[
	\frac{d\mathbf{x}}{dt} = A \mathbf{x} + \mathbf{b}
	\]
	
	\[
	r_i = \sum_{j=0}^{n-1} A_{ij} x_j
	\]
	\begin{lstlisting}
		#pragma once
		#include "cppNum/differentialSystem/system.hpp"
		#include <cassert>
		
		template<typename T>
		la::vector_t<T> ds::system_t::G(const la::vector_t<T> &x, const la::vector_t<T> &p) {
		int n=x.size();
		assert(p.size()==n*n);
		la::vector_t<T> r=la::vector_t<T>::Zero(n);
		for(int i=0; i<n; i++)
			for(int j=0; j<n; j++)
			r(i)+=p(i*n+j)*x(j);
		return r;
		}
	\end{lstlisting}
\end{frame}
	
\begin{frame}
\frametitle{Implementation: Run Time Difference \\
	\small \color{rwth-blue} Software Tests 2.4: Convex Polynomial and Cosh Function}
	\begin{figure}
		\centering
		\includegraphics[width=0.65\textwidth]{figures/2.4_4th_order_convex_polynomial.png}
		\vspace{0.3cm}
		\includegraphics[width=0.65\textwidth]{figures/2.4_cosh.png}
	\end{figure}
\end{frame}
	
\begin{frame}
\frametitle{Implementation: Run Time Difference \\
	\small \color{rwth-blue} Software Tests 2.5: Fountain Chain and Linear ODE}
	\begin{figure}
		\centering
		\includegraphics[width=0.65\textwidth]{figures/2.5_fountain_chain.png}
		\vspace{0.3cm}
		\includegraphics[width=0.65\textwidth]{figures/2.5_linear_ode.png}
	\end{figure}
\end{frame}
	
\begin{frame}
\frametitle{Implementation: Run Time Difference \\
	\small \color{rwth-blue} Software Tests: Conclusion}
	\begin{itemize}
		\item Differences between the versions with and without exception handling under different problem sizes:
		\begin{itemize}
			\item The difference is minimal because the resources used for exception handling in the program are very small and almost negligible. 
			\item Most of the resources are utilized for calculating derivatives, performing differentiation, and iterative solving.
		\end{itemize}
	\end{itemize}
\end{frame}
			
\section{Project Management}
\begin{frame}
\frametitle{Project Management \\
	\small \color{rwth-blue} Task}
	\begin{itemize}	
			\item \textbf{1.Self-study course:}
				\begin{itemize}
					\item Discuss problems in group in Discord.
					\item Read source code.
				\end{itemize}
			\item \textbf{2.Extend cppNum with exception handling:}
				\begin{itemize}
					\item Classification of Exceptions
					\item Create exception classes
					\item Add exception classes with try-catch to source code
				\end{itemize}
			\item \textbf{3.Design scalable case studies:}
				\begin{itemize}
				\item Implent new cases
				\item Add timing and plotting method
				\item Visualization
				\item Test and Debug
				\end{itemize}
			\item \textbf{4.Run time difference Analysis:}
			\item \textbf{5.Presentation:}
				\begin{itemize}
				\item Analysis (user requirements , use case)
				\item Source code and design
				\item Project management and live-demo(test)
				\item Case study(example) and run time analysis
				\end{itemize}
			\item *The following page of the PDF outlines the responsibilities of each person.
	\end{itemize}
\end{frame}
	
\begin{frame}
\frametitle{Project Management \\
	\small \color{rwth-blue} Gantt Chart}
	
	\begin{center}
		\includegraphics[width=\textwidth]{figures/project management.png}
	\end{center}
\end{frame}

\begin{frame}
\frametitle{Project Management \\
	\small \color{rwth-blue} Task Assignment}
	
	\begin{flushleft}
		\includegraphics[height=\textheight,keepaspectratio]{figures/project management.png}
	\end{flushleft}
\end{frame}
	
\section{Live Software Demo}

\begin{frame}
\frametitle{Live Software Demo \\
	\small \color{rwth-blue} Run in Xubuntu}
	\begin{itemize}	
			\item \textbf{1.Make:}
				\begin{itemize}
				\item make depend
				\item make
				\item make test
				\item make clean
				\end{itemize}
			\item \textbf{2.Execute executable files:}
				\begin{itemize}
				\item ./main.exe + Command-line arguments, (such as testing exception cases).
				\end{itemize}
			\item \textbf{3.Plot:}
				\begin{itemize}
				\item gnuplot gnuplot.plt
				\end{itemize}
	\end{itemize}
\end{frame}



\section{Summary and Conclusion}

\begin{frame}
\frametitle{Summary and Conclusion}
\end{frame}

\end{document}
